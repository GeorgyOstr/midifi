header fluid_header = '''
// I could do all this in Felix, but it'd be a LOT of mostly useless bindings.

#include <fluidsynth.h>
extern "C" {
#include <fluid_midi.h>
}
/* #include <mutex> */

extern unsigned long long midifi_ticks;
extern "C" int midifi_fluid_callback(void* data, unsigned int ms);

struct MidifiFluidData {
    MidifiFluidData(std::string path);
    ~MidifiFluidData();
    bool playing();
    void play();

    std::string path;
    fluid_settings_t* settings;
    fluid_synth_t* synth;
    fluid_player_t* player;
    fluid_audio_driver_t* audio_driver;
};

FLX_FINALISER(MidifiFluidData)
''' requires package 'fluid';


body fluid_body = '''
unsigned long long midifi_ticks = 0;

extern "C" int midifi_fluid_callback(void* player, unsigned int ms) {
    midifi_ticks = ms / static_cast<fluid_player_t*>(player)->deltatime;
    return fluid_player_callback(player, ms);
}

MidifiFluidData::MidifiFluidData(std::string path): path(path) {
    settings = new_fluid_settings();
    fluid_settings_setstr(settings, "audio.driver", "alsa");
    // XXX: This should probably be an option!
    fluid_settings_setstr(settings, "player.timing-source", "system");
    synth = new_fluid_synth(settings);
    // XXX: Another option!
    assert(fluid_synth_sfload(synth, "/usr/share/sounds/sf2/FluidR3_GM.sf2", 1)
           != FLUID_FAILED);
    player = new_fluid_player(synth);
    assert(player->use_system_timer);
    audio_driver = new_fluid_audio_driver(settings, synth);
}

bool MidifiFluidData::playing() { return player->status == FLUID_PLAYER_PLAYING; }

void MidifiFluidData::play() {
    if (playing()) return;
    midifi_ticks = 0;
    fluid_player_add(player, path.c_str());
    player->system_timer = new_fluid_timer(static_cast<int>(player->deltatime),
                                           midifi_fluid_callback,
                                           static_cast<void*>(player), 1, 0, 0);
    assert(player->system_timer); // XXX: This should handle errors. Stupid C APIs.
}

MidifiFluidData::~MidifiFluidData() {
    delete_fluid_audio_driver(audio_driver);
    delete_fluid_player(player);
    delete_fluid_synth(synth);
    delete_fluid_settings(settings);
}
''';


type FluidData = 'MidifiFluidData*' requires
    finaliser 'MidifiFluidData_finaliser', fluid_header, fluid_body;
ctor FluidData: string = 'new MidifiFluidData($1)';
proc play: FluidData = '$1->play();';
fun playing: FluidData -> bool = '$1->playing()';

gen ticks: 1 -> int = 'static_cast<int>(midifi_ticks)';
