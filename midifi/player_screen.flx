include 'stl/stl_vector';

rename fun mkvec[T] = Stl_Vector::create[T];
// XXX: Not type-safe in the Felix world!
proc set_vec_iterator[I,T]: I * T = '*$1 = $2;';


fun key_number_info(k: int) =>
    let k' = k - 24 in
    k' / 12 - 1, keys.(size$ k' % 12);


fun x_offset(octave: int, k: Key) =>
    let base_x = octave.float * values.octave_width +
                 k.d.float * values.white_key_width in
    if k.is_sharp
    then base_x + values.white_key_width - values.black_key_width / 2.0f
    else base_x endif;



track_colors := varray[Color] (
    Colors::Green,
    Colors::Blue
);


struct NoteFall {
    view: &View;
    bottom: float;
    tracks: stl_vector[stl_vector[RectangleShape]];
}

ctor NoteFall(midi: MidiFile::MidiFile) = {
    view := View$ FloatRect (0.0f, 0.0f, values.window_width.float,
                             values.window_height.float);
    self := NoteFall (new view, 0.0f, #mkvec[stl_vector[RectangleShape]]);
    midi.link_note_pairs;

    last_note := 0.0f;
    /* bottom := 0.0f; */

    for var tn in 0 upto midi.ntracks - 1 do
        track := #mkvec[RectangleShape];
        color := track_colors.((track_colors.len - tn.size) % track_colors.len);

        evtloop:for var en in 0 upto (midi.nevents tn) - 1 do
            event := midi.[tn.size].[en.size];

            if event.is_note_on and event.is_linked do
                kn := event.key_number;
                if kn < 24 continue evtloop; // XXX: This ignores A0-B0.

                var octave, key = kn.key_number_info;
                xpos := x_offset (octave - 1, key);
                ypos := event.tick.float * values.tick_height;
                // XXX: I have NO clue why this is necessary...but it is!
                xpos = xpos - 4.0f * values.white_key_width;

                r_height := event.tick_duration.float * values.tick_height;
                r_width := key.width;

                if key.follows_sharp do
                    r_width = r_width - values.black_key_width / 2.0f;
                    xpos = xpos + values.black_key_width / 2.0f;
                done

                if key.precedes_sharp perform
                    r_width = r_width - values.black_key_width / 2.0f;

                r := RectangleShape$ Vector2f (r_width, r_height);
                r.set_position (xpos, ypos);
                r.set_fill_color
                    if key.is_sharp then color - values.darken_color
                    else color endif;
                r.set_outline_color Colors::Black;
                r.set_outline_thickness values.line_width;

                push_back (track, r);

                last_note = max (last_note, ypos);
                self.bottom = max (self.bottom, ypos + r_height);
            done
        done

        push_back (self.tracks, track);
    done

    // We need to now flip all the tracks upside-down.
    for (var ti = self.tracks.begin; ti != self.tracks.end; ++ti;) perform
        for (var ni = (*ti).begin; ni != (*ti).end; ++ni;) do
            // XXX: Work around optimizing (see comment in draw_onto).
            r = *ni;
            r.set_position (r.position.x, last_note - r.position.y);
            set_vec_iterator (ni, r);
        done

    initial_space := 4.0f * midi.tpq.float * values.tick_height;
    // XXX: Work around optimizing (see comment in draw_onto).
    view = *self.view;
    view.set_center$ Vector2f (0.0f, self.bottom + initial_space);
    *self.view = view;

    return self;
}

proc draw_onto(self: NoteFall, w: RenderWindow) {
    /*
       XXX: This is to get around Felix optimizing-out a bunch of stuff that
       cause the view to NEVER MOVE.
    */
    v := *self.view;
    space_bottom := values.window_height.float / 2.0f - values.white_key_height;
    if v.center.y + space_bottom <= self.bottom perform fluid.play;
    if fluid.playing do
        v.set_center$ Vector2f (0.0f, self.bottom - space_bottom - #ticks.float *
                                      values.tick_height);
    else
        v.set_center$ v.center - Vector2f (0.0f, 0.5f);
    done
    w.set_view v;
    *self.view = v;

    for (var ti = self.tracks.begin; ti != self.tracks.end; ++ti;) perform
        for (var ni = (*ti).begin; ni != (*ti).end; ++ni;) do
            w.draw$ *ni;
        done

    w.set_view w.default_view;
}


struct Keyboard {
    white_keys: stl_vector[RectangleShape];
    black_keys: stl_vector[RectangleShape];
}

ctor Keyboard() = {
    self := Keyboard (#mkvec[RectangleShape], #mkvec[RectangleShape]);

    root:for var octave in 0 upto values.octaves_to_show perform
        for key in keys do
            xpos := x_offset (octave, key);
            ypos := values.window_height.float - values.white_key_height;
            r := RectangleShape$ Vector2f (key.width, key.height);
            r.set_position (xpos, ypos);

            if key.is_sharp do
                r.set_fill_color Colors::Black;
                push_back (self.black_keys, r);
            else
                r.set_fill_color Colors::White;
                r.set_outline_color Colors::Black;
                r.set_outline_thickness values.line_width;
                push_back (self.white_keys, r);
            done

            // Only one C is shown at the last octave.
            if key.is_c and octave == values.octaves_to_show break root;
        done

    return self;
}

proc draw_onto(self: Keyboard, w: RenderWindow) {
    for (var ki = self.white_keys.begin; ki != self.white_keys.end; ++ki;) perform
        w.draw$ *ki;

    for (ki = self.black_keys.begin; ki != self.black_keys.end; ++ki;) perform
        w.draw$ *ki;
}


struct PlayerScreen {
    n: NoteFall;
    kb: Keyboard;
}

ctor PlayerScreen(midi: MidiFile::MidiFile) =>
    PlayerScreen (NoteFall midi, #Keyboard);

proc draw_onto(self: PlayerScreen, w: RenderWindow) {
    draw_onto (self.n, w);
    draw_onto (self.kb, w);
}
